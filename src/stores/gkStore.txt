

Sequence is 2-bit encoded
QVs are 5-bit encoded. (0-31 inclusive)

From the FASTQ wikipedia: "Sanger format can encode a Phred quality score from 0 to 93 using
ASCII 33 to 126 (although in raw read data the Phred quality score rarely exceeds 60, higher
scores are possible in assemblies or read maps)."
The encoding starts at ! and ends with ~

A gkSeqDataPointers object stores 1024-byte block offsets into a single file of per-technology
encoded sequence data.  This can store up to 2^32 * 1024 = 4TB of encoded sequence data.

A gkSeqData object stores actual pointers to decoded seq/qlt data.

At present, the two classes above are a union, though that might change.

A gkRead object stores all the metadata useful for assembly.
It is currently 3 64-bit words, so 24 bytes.

 -   4 million reads ->   96 MB data
 - 128 million reads -> 3072 MB data (a bit big to suck it all into memory)

The gkRead you get from the gkStore is really a pointer to a mmap'd disk file.
The file has integer pointers to the sequence data.  The gkSeqData object
is returned by the loader functions and is populated with the sequence data.
The gkRead this is called on MUST have _diskbacked == true, and the gkRead
that is returned will have _diskbacked == false.  If not, false is returned
(thus, you can test if you have sequence loaded or not).


Stubs for encoding/decoding sequence and quality values.  Presently, there isn't any encoding.
The encoding from CA would pack two ways:
  
 - sequence into 2 bits if there were no N's, and 4 bits if there were.
  
 - sequence + quals into 8 bits, 2 for sequence, 6 for qual, with some special cases at the
   higher encoded quality values (e.g., qv=63 encoded an N).
  
Eventually, we might want to store more stuff, like the PacBio insert, delete and substitution
scores.
  

----------
The full gkpStore:

  info      - metadata on the store     - sucked into memory, less than 1 KB data
  libraries - metadata on the libraries - sucked into memory, less than 1 KB data
  reads     - metadata on the reads     - memory mapped, 200 MB for 8 million reads
  blobs     - sequence/quality data     - memory mapped, huge

----------
A partitioned gkpStore:

If the data is to be partitioned too, we need to save a map from the original ID to the partition
ID.  This will allow us to access the partitioned data with a global id.  It is global to the store,
and is only 4 bytes per id.  With 8 million reads, that's 32MB.

For convenience, we also store a list of the reads in this partition.  This can be computed
on demand from the partiton map above.

The two additional files for a partitioned store are the partitioned data and the map

  blobs.#### - copy of sequence/quality data from 'seqs'.
  partitions - number of partiions (convenience)
             - map from uint32 IID to uint32 index into data.#### - 32 MB data for 8 million reads.

----------------------------------------

Input example

name      = lib1
preset    = (technology)
(feature) = (value)
input-file.extension.compression
input-file.extension.compression
