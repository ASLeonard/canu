
This is a prototypical build system for non-recursive whole-directory
'make's.  This readme file is going to start you with the basics.

The correct 'make' to use is 'gmake'.  The correct version of gmake to
use is gmake-3.80 with the GNU accepted patch for this problem
  http://savannah.gnu.org/bugs/?func=detailbug&bug_id=1517&group_id=71
Patched source can be found around here somewhere.  Find Ross.

On the AIX machines, gmake-3.80 has this patch and will work just fine.
On Tru64, the patched version of gmake-3.80 called 'gmake-3.80a' exists,
and source should be at
  /usr/local/ir/ports/make-3.80-patched.tgz

A symlink to the binary is at 
  /usr/local/ir/bin/gmake
on Tru64.  For convenience there is a symlink from
  /usr/local/ir/bin/gmake
to
  /usr/local/bin/gmake
on AIX.

******** QUICK START

To get started (using bash for command line examples)
% alias make=/usr/local/ir/bin/gmake

To make all targets
% make all

Local targets are supported:
To make all of RASCAL
% make ../RASCAL/.all

To make and install the binaries and libs of Framework
% make ../COMPASS/src/Framework/.install

Other targets supported are clean, depends-clean, real-clean and ls.

If you either change platforms then you must do
% make real-clean

For convenience:
% make ls
just does ls of all targets in the directories where they are built.

One can also work within directories so long as one is careful, since
* subdirectories don't know about the dependencies upon siblings
  (that is, they don't check the time-stamps on siblings)
* automatically computed dependencies computed relative to one subdir
  do not make sense when used in another sibdir.  So if you have been
  previously building from somewhere else, you need to clean the
  depends information before you try to build.
% make ../COMPASS/src/Framework/.depends-clean
% cd ../COMPARSS/src/Framework/
% make -f ../../../build/Makefile all
Better yet, use an environment variable
% setenv makefile /home/ripper/assem/cds/IR/build/Makefile
% make -f $makefile
Or even
% alias make '/usr/local/ir/bin/gmake -f $makefile'

DO NOT MAKE A SYMLINK OR COPY OF build/Makefile from where you are
compiling.  Firstly, that just won't work, because the build directory
contains auxilliary files which will then not be found by your hack.
Secondly, you are asking for cvs trouble either because the copy
you make could diverge or because cvs doesn't deal with symlinks well.

### Questions you might have
Q) How come I can't do 
  make real-clean all
and get something that I think I should?
A) The real-clean and depends-clean targets remove the depends
files.  Since that is their purpose, there is no sense rebuilding
any unbuilt dependencies just to remove them.  In fact, it can be
pretty annoying.  'make' provides a very limited way to prevent
this unnecessary rebuilding from occurring (though perhaps I am just
not thinking about it carefully enough).  At present, if any of the
targets of 'make' in this system match *-clean, then no dependency
files will be built or even included (since an include also can
trigger a build).
  make clean all
will work, if that is any consolation.

Q) I use includes in other directories.  How do I add to the compiler
include path for the objects in one directory without making a global
change to Make.compilers?
A) gmake-3.80 supports dependency-style assignments which are in
effect only when that rule is being evaluated.  Suppose I want to
include directories foo and bar when my .o's are being built.  Then,
  $/%.o $/%.d: CXXFLAGS += -Ifoo -Ibar
  $/%.o $/%.d: CFLAGS += -Ifoo -Ibar
will do it.  Note: the $/%.d pattern is included so that these flags
are present when the depends files are built (which you usually need).

Q) How do I build everything with GCC?
A) Set the WITH_GNU variable to something, either on the command line or
in the environment, e.g.
  make WITH_GNU=1
Programs will install into an appropriate '-gcc' directory.

Q) How do I build with the debug flags on?
A) Set the WITH_DEBUG variable to something, either on the command line
or in the environment, e.g.
  export WITH_DEBUG=1
  make
There is also a WITH_PROFILE flag which can be set.  Programs will install
into an appropriate '-debug' or '-prof' directory.

Q) One of the subprojects has a buggy build or a buggy Make.include.
How do I get the build system to ignore it?
A) One option is deleting the directory, since Make.include files
which do not exist and silently skipped.  However, the current, highly
experimental, way to do this without deleting is by using the WITHOUT
variable.  Specifying paths in this variable will cause the
Make.include file in the directory to not be read.  For example,
  make WITHOUT="../RCM/src/ ../TCBB/"
(terminating /'s are mandatory) will cause no build information to
be read at all for these directories.

Q) The Make.compilers file sucks.  I've hacked up my own.  How do I
use this instead?
A) It is bad to do this.  But sometimes you just have to.  You can
override it by setting the variable MAKE_COMPILERS to the path (full
or relative) of you Make.compilers file.  e.g.
  make MAKE_COMPILERS=/home/ripper/Make.compilers
or
  export MAKE_COMPILERS=/home/ripper/Make.compilers
  make
If the Make.compilers file continues to be dissatisfying, then talk
to me about it and we should work something out.  Currently, this is
a hack and may not last long.

Q) I have this package that I want to build in the system, but I
don't want to add all those Make.include files just to add it to the
build.  How do I fall back to recursive make?
A) It is bad to do this, but if you have to, there is a way.  If
you add an include file to the root directory of the recursively made
unit of the form (copy that first line exactly):
 RECURSIVE +=$/.

 $/src/libfoo.a: $/.all

 $/.all:
	cd `dirname $@` && ${MAKE} CC=${CC} CXX=${CXX} all
 $/.clean:
	cd `dirname $@` && ${MAKE} clean
 $/.real-clean:
	cd `dirname $@` && ${MAKE} clean
 $/.install:
	cd `dirname $@` && ${MAKE} PREFIX=${INSTALL/} install
All recursive makes, incorporated into the build system this way
must provide relative all, clean, real-clean, and install targets
(though you are free to make any of them empty).  The commands
for each target in this example are a guess.  It is generally
a good idea to specify targets (e.g. libfoo.a, program) which this
package may be supplying so that rebuilds of this package are
triggered properly.

### Longwinded discussion

The current build system is essentially a series of either explicit or
implicit recursive 'make's.

Explicit recursive 'make's are those which one invocation of 'make'
results in a series of separate invocations of 'make' in individual
subprojects, often with shell-scripting glue in between to address
platform/installation dependent issues.

Implicit recursive 'make's come about when no invocation of 'make'
exists to do the build, but developers all are aware that projectA
relies on projectB and thus projectA should get built before projectB
and any updates to projectA will require some rebuilding of projectB
("safety" typically dictates that all of projectB be rebuilt).

Both cases have equivalent liabilities:
* Inter-project dependence is only partially encoded.
  - Cross interdependence between projects is never encoded, leading to
    the annoying 'make ; make' command.
  - The only guarrantee of a consistent build is one which starts
    completely clean.
* Compiler and compiler flag choices are project specific.
  - One might be unable to link libraries across projects due to
    inconsistent compiler/flag use.
  - Many per-file changes are required to port to another platform.

Additionally, implicit recursive 'make's have the liability that
technology transfer to other agencies or individuals requires an
incredible amount of hand-holding.

A lot of this was discussed in
   http://www.tip.net.au/~millerp/rmch/recu-make-cons-harm.html
in which the author points out many of th flaws with the conventional
recursive use of 'make' and shows how it is possible to construct a
viable non-recursive 'make', though recursive use of "include".

### Technical discussion

My IR/build system is based on recursive inclusion.  When 'make' is
invoked with IR/build/Makefile (either by invoking 'make' in the
IR/build/ directory or by using 'make -f') the file, Make.compilers,
which resides in the same directory as IR/build/Makefile is openned
and read for various platform specific defines.  Then the file
Make.include in _the current directory_ is read.  The Make.include
file contains various definitions relating to the build in the current
directory as well as recursive inclusions.  Once all recursive
inclusions have finished, a set of *.d files in each Make.include
directory is read to include automatically generated rules (for C and
C++ compiles).

NOTE{
It is currently possible for cyclic inclusions to occur.  So long as
the inclusions more or less match the filesystem hierarchy, this will
not happen.  We assume that the heirachy of includes is a tree.
}

An included file is expected to make all file references transparently
relocatable.  To do this, the build system maintains a variable $/
which always refers to the relative path from the directory where
'make' was invoked to the directory of the Make.include up to and
including a slash.  Thus, file.c in the same directory as the
Make.include file is referred to within that Make.include file as
$/file.c, the parent directory of the Make.include file as $/.., and
the current directory as $/. (but not $/, which may be an empty
string).  The purpose of $/ is to make the contents of Make.include
relocatable to any place in the filesystem.

Since we can assume that the contents of $/ are unique for
every Make.include, we can use it as a local namespace for variable
definition.  The current convention for local variables are
 $/.C_SRCS    C source files which get compiled (excluding headers)
 $/.CXX_SRCS  C++ source files which get compiled (excluding headers)
 $/.C_EXES    program generated with the C linker
 $/.CXX_EXES  program generated with the C++ linker
 $/.C_LIBS    .a archive files of C functions
 $/.CXX_LIBS  .a archive files of C++ functions
NOTE{
I don't know of any reason why C_LIBS and CXX_LIBS are diffierent
variables.  Does anyone know when you use anything but the same 'ar'
command to build them?
}
 $/.CXX_SHLIBS  .so shared libraries
 $/.CLEAN      intermediate files or wildcard patterns
 $/.REAL-CLEAN less intermediate files or wildcard patterns
There are additional variables used by the .install targets to control
where installed things are placed, but we might change install so it
is not stable enough to mention yet.  Additional dependencies which
the build system cannot infer are also declared in Make.include.

Example of a Make.include file:
 $/.C_SRCS := $/hello.c
 $/.C_EXES := $/hello
 $/.CLEAN:=$/*.o
 ${$/.C_EXES}: $/hello.o

The inclusion of subdirectories is done, not with 'make''s 'include'
function, but with a slightly more complicated wrapper (which pushes
and pops the $/ value appropriately) which is invoked by
 $(eval $(call Include,DIR))
where DIR is the /-terminated path to the included directory, like
'$/foo/'.

Once all the inclusions have finished, subtargets are generated for
each directory visited.  These subtargets are all of the form $/.all,
$/.clean, $/.real-clean, ... .  The top-level targets, all, clean,
..., are equivalent to .all, .clean, ... .
 $/.all: builds all targets at $/. and below
 $/.clean: removes targets and files specified by $/.CLEAN at $/. and
   below
 $/.depends-clean: removes the auto-generated $/*.d depends files at $/.
   and below
 $/.real-clean: does $/.clean and $/.depends-clean and removes files
   specified by $/.REAL-CLEAN
 $/.ls: does 'ls -l' of all targets in $/. and below.
 $/.install: does $/.all and the tries to copy stuff to ${INSTALL/} under
   an architecture appropriate subdirectory.

